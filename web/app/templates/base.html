<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Las Cucarachas Gambling Help Line</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
details.collapsible summary { list-style: none; }
details.collapsible summary::-webkit-details-marker { display: none; }
details.collapsible .collapsible-chevron { transition: transform 0.2s ease; }
details.collapsible[open] .collapsible-chevron { transform: rotate(90deg); }


#blackjack-widget {
  box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.blackjack-collapsed {
  transform: translateY(-12px);
  opacity: 0.35;
}

#blackjack-widget.blackjack-collapsed .blackjack-body {
  display: none;
}

.blackjack-section {
  margin-bottom: 0.75rem;
}

.blackjack-cards {
  display: flex;
  gap: 0.35rem;
  flex-wrap: wrap;
}

.blackjack-card {
  width: 40px;
  height: 56px;
  border-radius: 0.5rem;
  border: 1px solid rgba(148, 163, 184, 0.8);
  background: white;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 4px;
  font-size: 0.75rem;
  line-height: 1;
  position: relative;
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
}

.blackjack-card.red {
  color: #dc2626;
}

.blackjack-card .corner {
  font-weight: 600;
}

.blackjack-card .corner.bottom {
  transform: rotate(180deg);
}

.blackjack-card .suit {
  font-size: 1rem;
  align-self: center;
}

.blackjack-card.back {
  background: linear-gradient(135deg, #1f2937 0%, #0f172a 100%);
  border-color: rgba(30, 41, 59, 0.9);
  color: white;
  justify-content: center;
  align-items: center;
  font-size: 0.8rem;
  letter-spacing: 0.1em;
}

.blackjack-buttons button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.blackjack-chip.active {
  box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.45), 0 10px 18px rgba(15, 23, 42, 0.25);
  transform: translateY(-2px);
}

.blackjack-chip {
  position: relative;
  width: 48px;
  height: 48px;
  border-radius: 9999px;
  border: 4px solid rgba(255, 255, 255, 0.85);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  font-weight: 700;
  color: #fff;
  text-shadow: 0 1px 2px rgba(15, 23, 42, 0.45);
  transition: transform 0.15s ease, box-shadow 0.15s ease;
  box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.35), 0 4px 10px rgba(15, 23, 42, 0.2);
  cursor: pointer;
  padding: 0;
}

.blackjack-chip:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  transform: none;
  box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.2);
}

.blackjack-chip::before,
.blackjack-chip::after {
  content: "";
  position: absolute;
  border-radius: 9999px;
  inset: 6px;
  border: 2px dashed rgba(255, 255, 255, 0.6);
}

.blackjack-chip::after {
  inset: 12px;
  border-style: solid;
  border-width: 2px;
  opacity: 0.55;
}

.chip-red { background: #ef4444; }
.chip-blue { background: #3b82f6; }
.chip-green { background: #22c55e; }
.chip-orange { background: #f97316; }
.chip-black { background: #111827; }

</style>
</head>
<body class="bg-gray-100 min-h-screen">
<nav class="bg-gray-800 text-white p-4 mb-6">
  <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3">
    <h1 class="text-xl font-bold">Las Cucarachas Bet Tracker</h1>
    <div class="flex items-center gap-4 text-sm">
      <a href="/" class="hover:underline">Dashboard</a>
      <a href="/catalog" class="hover:underline">League Catalog</a>
      <a href="/stats" class="hover:underline">Player Stats</a>
      <a href="/games" class="hover:underline">Games Hub</a>
      <a href="/ai-tools" class="hover:underline">AI Insights</a>
      <a href="/archived" class="hover:underline">Archived Wagers</a>
      {% if request.state.auth_user and request.state.auth_user.is_admin %}
      <a href="{{ admin_dashboard_path }}" class="hover:underline">Admin</a>
      {% endif %}
      {% if request.state.auth_user %}
      <span class="hidden sm:inline text-gray-300">Signed in as {{ request.state.auth_user.username }}</span>
      <form method="post" action="/logout" class="inline">
        <button class="hover:underline">Sign out</button>
      </form>
      {% else %}
      <a href="/admin" class="hover:underline">Sign in</a>
      {% endif %}
    </div>
  </div>
</nav>
<main class="container mx-auto px-4">
{% block content %}{% endblock %}
</main>
<div id="blackjack-widget" class="fixed top-24 right-4 w-72 bg-white rounded-2xl border border-gray-200 p-4 text-sm blackjack-collapsed">
  <div class="flex items-center justify-between mb-3">
    <div class="flex items-center gap-2">
      <button id="blackjack-toggle" title="Toggle blackjack" class="text-xs bg-slate-200 text-slate-700 px-2 py-1 rounded hover:bg-slate-300">+</button>
      <h2 class="text-base font-semibold">Mini Blackjack</h2>
    </div>
    <button id="blackjack-new" class="text-xs bg-gray-900 text-white px-3 py-1 rounded hover:bg-gray-700">Deal</button>
  </div>
  <div class="blackjack-body space-y-4">
    <div class="blackjack-section">
      <h3 class="text-xs uppercase tracking-wide text-gray-500 mb-1">Dealer</h3>
      <div id="blackjack-dealer-cards" class="blackjack-cards"></div>
      <p id="blackjack-dealer-score" class="text-xs text-gray-500 mt-1"></p>
    </div>
    <div class="blackjack-section">
      <h3 class="text-xs uppercase tracking-wide text-gray-500 mb-1">Player</h3>
      <div id="blackjack-player-hands" class="space-y-2"></div>
    </div>
    <div class="blackjack-section border-t border-gray-200 pt-2 mt-2">
      <div class="flex items-center justify-between text-xs text-gray-600 mb-2">
        <span>Bankroll: <strong>$<span id="blackjack-bankroll">100</span></strong></span>
        <span>Bet: <strong>$<span id="blackjack-current-bet">0</span></strong></span>
      </div>
      <div id="blackjack-bet-area" class="border-2 border-dashed border-slate-300 rounded-xl p-3 text-center cursor-pointer hover:border-slate-500 transition-colors mb-3">
        <p class="text-xs text-gray-600">Click to drop your selected chip.</p>
        <div id="blackjack-active-chip-display" class="text-xs text-gray-500 mt-1"></div>
        <div id="blackjack-bet-chips" class="flex flex-wrap justify-center gap-1 text-xs text-gray-700 mt-2"></div>
      </div>
      <div class="flex items-center justify-between text-xs text-gray-600 mb-1">
        <span>Select a chip</span>
        <button id="blackjack-clear-bet" class="bg-slate-200 text-slate-700 rounded-full px-3 py-1 text-xs">Clear</button>
      </div>
      <div class="flex flex-wrap gap-3" id="blackjack-chip-tray">
        <button class="blackjack-chip chip-red" data-amount="5">$5</button>
        <button class="blackjack-chip chip-blue" data-amount="10">$10</button>
        <button class="blackjack-chip chip-green" data-amount="25">$25</button>
        <button class="blackjack-chip chip-orange" data-amount="50">$50</button>
        <button class="blackjack-chip chip-black" data-amount="100">$100</button>
      </div>
    </div>
    <p id="blackjack-message" class="text-xs text-gray-600 min-h-[2rem]"></p>
    <div class="blackjack-buttons flex flex-wrap gap-2 mt-2">
      <button id="blackjack-hit" class="flex-1 bg-emerald-500 text-white rounded px-3 py-1 text-xs hover:bg-emerald-600">Hit</button>
      <button id="blackjack-stand" class="flex-1 bg-blue-500 text-white rounded px-3 py-1 text-xs hover:bg-blue-600">Stand</button>
      <button id="blackjack-double" class="flex-1 bg-orange-500 text-white rounded px-3 py-1 text-xs hover:bg-orange-600">Double</button>
      <button id="blackjack-split" class="flex-1 bg-purple-500 text-white rounded px-3 py-1 text-xs hover:bg-purple-600">Split</button>
    </div>
  </div>
</div>
<script>
  (function blackjackWidget() {
    const ranks = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];
    const suits = ['♠', '♥', '♦', '♣'];
    const cardValues = {
      A: 11,
      K: 10,
      Q: 10,
      J: 10,
      '10': 10,
      '9': 9,
      '8': 8,
      '7': 7,
      '6': 6,
      '5': 5,
      '4': 4,
      '3': 3,
      '2': 2,
    };

    function formatCurrency(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) {
        return '0';
      }
      return num % 1 === 0 ? num.toString() : num.toFixed(2);
    }

    const newGameButton = document.getElementById('blackjack-new');
    const hitButton = document.getElementById('blackjack-hit');
    const standButton = document.getElementById('blackjack-stand');
    const doubleButton = document.getElementById('blackjack-double');
    const splitButton = document.getElementById('blackjack-split');
    const dealerCardsEl = document.getElementById('blackjack-dealer-cards');
    const dealerScoreEl = document.getElementById('blackjack-dealer-score');
    const playerHandsEl = document.getElementById('blackjack-player-hands');
    const messageEl = document.getElementById('blackjack-message');
    const bankrollEl = document.getElementById('blackjack-bankroll');
    const currentBetEl = document.getElementById('blackjack-current-bet');
    const chipButtons = Array.from(document.querySelectorAll('.blackjack-chip'));
    const clearBetButton = document.getElementById('blackjack-clear-bet');
    const betArea = document.getElementById('blackjack-bet-area');
    const betChipsEl = document.getElementById('blackjack-bet-chips');
    const activeChipDisplay = document.getElementById('blackjack-active-chip-display');
    const widget = document.getElementById('blackjack-widget');
    const toggleButton = document.getElementById('blackjack-toggle');

    if (!newGameButton || !hitButton) {
      return;
    }

    const state = {
      deck: [],
      dealer: [],
      playerHands: [],
      activeHand: 0,
      revealDealer: false,
      finished: true,
      message: [],
      bankroll: 100,
      baseBet: 0,
      betChips: [],
      selectedChip: null,
      collapsed: true,
    };

    function createDeck() {
      const deck = [];
      ranks.forEach((rank) => {
        suits.forEach((suit) => {
          deck.push({ rank, suit });
        });
      });
      for (let i = deck.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    function drawCard() {
      if (state.deck.length === 0) {
        state.deck = createDeck();
      }
      return state.deck.pop();
    }

    function handValue(cards) {
      let total = 0;
      let aces = 0;
      cards.forEach((card) => {
        total += cardValues[card.rank];
        if (card.rank === 'A') {
          aces += 1;
        }
      });
      while (total > 21 && aces > 0) {
        total -= 10;
        aces -= 1;
      }
      return total;
    }

    function isBlackjack(cards) {
      return cards.length === 2 && handValue(cards) === 21;
    }

    function createCardElement(card, hidden) {
      const el = document.createElement('div');
      if (hidden) {
        el.className = 'blackjack-card back';
        el.textContent = '◆◇';
        return el;
      }
      const isRed = card.suit === '♥' || card.suit === '♦';
      el.className = 'blackjack-card' + (isRed ? ' red' : '');
      const top = document.createElement('span');
      top.className = 'corner top';
      top.textContent = card.rank;
      const suit = document.createElement('span');
      suit.className = 'suit';
      suit.textContent = card.suit;
      const bottom = document.createElement('span');
      bottom.className = 'corner bottom';
      bottom.textContent = card.rank;
      el.appendChild(top);
      el.appendChild(suit);
      el.appendChild(bottom);
      return el;
    }

    function canSplit(hand) {
      if (!hand || hand.cards.length !== 2) {
        return false;
      }
      const [first, second] = hand.cards;
      if (first.rank === second.rank) {
        return true;
      }
      const tenValues = new Set(['10', 'J', 'Q', 'K']);
      return tenValues.has(first.rank) && tenValues.has(second.rank);
    }

    function formatOutcome(result) {
      switch (result) {
        case 'blackjack':
          return 'Blackjack!';
        case 'win':
          return 'Win';
        case 'lose':
          return 'Lose';
        case 'push':
          return 'Push';
        case 'bust':
          return 'Bust';
        default:
          return '';
      }
    }

    function pushMessage(message) {
      if (!message) {
        return;
      }
      state.message.push(message);
    }

    function resetMessages(message) {
      state.message = message ? [message] : [];
    }

    function currentBetTotal() {
      return state.betChips.reduce((sum, chip) => sum + chip, 0);
    }

    function refreshChipSelection() {
      chipButtons.forEach((button) => {
        const amount = Number(button.dataset.amount);
        if (!Number.isFinite(amount)) {
          return;
        }
        button.classList.toggle('active', state.selectedChip === amount);
      });
      if (activeChipDisplay) {
        activeChipDisplay.textContent = state.selectedChip
          ? `Selected chip: $${formatCurrency(state.selectedChip)}`
          : 'No chip selected';
      }
    }

    function renderBetChips() {
      if (!betChipsEl) {
        return;
      }
      betChipsEl.innerHTML = '';
      if (!state.betChips.length) {
        const empty = document.createElement('span');
        empty.className = 'text-xs text-gray-400';
        empty.textContent = 'No chips placed.';
        betChipsEl.appendChild(empty);
        return;
      }
      state.betChips.forEach((amount, index) => {
        const chip = document.createElement('span');
        chip.className = 'px-2 py-1 rounded-full bg-slate-100 border border-slate-300';
        chip.textContent = `$${formatCurrency(amount)}`;
        chip.title = `Chip ${index + 1}`;
        betChipsEl.appendChild(chip);
      });
    }

    function selectChip(amount) {
      if (!state.finished) {
        resetMessages('Finish the current hand before changing chips.');
        updateUI();
        return;
      }
      const normalized = Number(amount);
      if (!Number.isFinite(normalized) || normalized <= 0) {
        state.selectedChip = null;
      } else {
        state.selectedChip = normalized;
        resetMessages(`Selected $${formatCurrency(normalized)} chip.`);
      }
      updateUI();
    }

    function handleBetAreaClick() {
      if (!state.finished) {
        resetMessages('Round in progress. Finish the hand first.');
        updateUI();
        return;
      }
      if (!state.selectedChip) {
        resetMessages('Select a chip first.');
        updateUI();
        return;
      }
      addToBet(state.selectedChip);
    }

    function addToBet(amount) {
      if (!state.finished) {
        resetMessages('Round in progress. Finish the hand first.');
        updateUI();
        return;
      }
      const normalized = Number(amount);
      if (!Number.isFinite(normalized) || normalized <= 0) {
        return;
      }
      if (state.bankroll <= 0) {
        resetMessages('You are out of bankroll.');
        updateUI();
        return;
      }
      const newTotal = currentBetTotal() + normalized;
      if (newTotal > state.bankroll) {
        resetMessages('Not enough bankroll for that chip.');
        updateUI();
        return;
      }
      state.betChips.push(normalized);
      state.baseBet = newTotal;
      resetMessages(`Betting $${formatCurrency(state.baseBet)}.`);
      updateUI();
    }

    function clearBet() {
      if (!state.finished) {
        return;
      }
      state.betChips = [];
      state.baseBet = 0;
      resetMessages('Bet cleared.');
      updateUI();
    }

    function renderDealer() {
      dealerCardsEl.innerHTML = '';
      state.dealer.forEach((card, index) => {
        const hidden = !state.revealDealer && index === 1;
        dealerCardsEl.appendChild(createCardElement(card, hidden));
      });
      if (state.revealDealer) {
        dealerScoreEl.textContent = `Total: ${handValue(state.dealer)}`;
      } else if (state.dealer.length) {
        dealerScoreEl.textContent = `Total: ${handValue([state.dealer[0]])} + ?`;
      } else {
        dealerScoreEl.textContent = '';
      }
    }

    function renderPlayerHands() {
      playerHandsEl.innerHTML = '';
      state.playerHands.forEach((hand, index) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'border rounded-lg p-2 ' + (index === state.activeHand && !state.finished ? 'bg-slate-100 border-slate-300' : 'bg-white border-slate-200');

        const header = document.createElement('div');
        header.className = 'flex items-center justify-between text-xs text-gray-600 mb-1';
        const label = document.createElement('span');
        const wagerDisplay = formatCurrency(hand.wager ?? state.baseBet);
        label.textContent = `Hand ${index + 1} · $${wagerDisplay}`;
        const status = document.createElement('span');
        if (hand.status === 'bust') {
          status.textContent = 'Bust';
        } else if (hand.result) {
          status.textContent = formatOutcome(hand.result);
        } else if (index === state.activeHand && !state.finished) {
          status.textContent = 'Your turn';
        } else {
          status.textContent = '';
        }
        header.appendChild(label);
        header.appendChild(status);
        wrapper.appendChild(header);

        const cardsEl = document.createElement('div');
        cardsEl.className = 'blackjack-cards';
        hand.cards.forEach((card) => {
          cardsEl.appendChild(createCardElement(card, false));
        });
        wrapper.appendChild(cardsEl);

        const total = document.createElement('p');
        total.className = 'text-xs text-gray-500 mt-1';
        total.textContent = `Total: ${handValue(hand.cards)}`;
        wrapper.appendChild(total);

        playerHandsEl.appendChild(wrapper);
      });
    }

    function updateMessages() {
      messageEl.innerHTML = state.message.map((line) => `<span>${line}</span>`).join('<br>');
    }

    function updateButtons() {
      const current = state.playerHands[state.activeHand];
      const inPlay = Boolean(current && !state.finished && current.status === 'playing');
      const currentWager = current ? current.wager || state.baseBet : 0;
      const canAdjustBet = state.finished;
      hitButton.disabled = !inPlay;
      standButton.disabled = !inPlay;
      doubleButton.disabled = !(inPlay && current.cards.length === 2 && !current.hasActed && state.bankroll >= currentWager);
      splitButton.disabled = !(inPlay && canSplit(current) && state.bankroll >= currentWager);
      newGameButton.textContent = state.finished ? 'Deal' : 'Restart';
      const canDeal = state.finished && state.baseBet > 0 && state.bankroll >= state.baseBet;
      newGameButton.disabled = !canDeal;
      chipButtons.forEach((button) => {
        button.disabled = !canAdjustBet;
      });
      if (clearBetButton) {
        clearBetButton.disabled = !canAdjustBet || state.baseBet === 0;
      }
      if (betArea) {
        if (canAdjustBet) {
          betArea.classList.remove('opacity-60', 'pointer-events-none');
        } else {
          betArea.classList.add('opacity-60', 'pointer-events-none');
        }
      }
    }

    function updateUI() {
      renderDealer();
      renderPlayerHands();
      renderBetChips();
      refreshChipSelection();
      updateMessages();
      bankrollEl.textContent = formatCurrency(state.bankroll);
      currentBetEl.textContent = formatCurrency(state.baseBet);
      updateButtons();
      if (widget) {
        widget.classList.toggle('blackjack-collapsed', state.collapsed);
      }
      if (toggleButton) {
        toggleButton.textContent = state.collapsed ? '+' : '−';
        toggleButton.setAttribute('aria-expanded', (!state.collapsed).toString());
      }
    }

    function setFinished() {
      state.finished = true;
      updateUI();
    }

    async function startDealerTurn() {
      state.revealDealer = true;
      updateUI();

      let dealerTotal = handValue(state.dealer);
      while (dealerTotal < 17) {
        await new Promise((resolve) => setTimeout(resolve, 900));
        state.dealer.push(drawCard());
        dealerTotal = handValue(state.dealer);
        updateUI();
      }

      dealerTotal = handValue(state.dealer);
      resetMessages(`Dealer stands at ${dealerTotal > 21 ? 'bust' : dealerTotal}.`);

      state.playerHands.forEach((hand, index) => {
        const wager = hand.wager || state.baseBet;
        if (hand.status === 'bust') {
          hand.result = 'bust';
          pushMessage(`Hand ${index + 1}: Bust. Dealer wins.`);
          return;
        }
        const playerTotal = handValue(hand.cards);
        if (dealerTotal > 21) {
          hand.result = 'win';
          state.bankroll += wager * 2;
          pushMessage(`Hand ${index + 1}: Dealer busts. You win $${formatCurrency(wager)}.`);
        } else if (playerTotal > dealerTotal) {
          hand.result = 'win';
          state.bankroll += wager * 2;
          pushMessage(`Hand ${index + 1}: You win $${formatCurrency(wager)}.`);
        } else if (playerTotal < dealerTotal) {
          hand.result = 'lose';
          pushMessage(`Hand ${index + 1}: Dealer wins.`);
        } else {
          hand.result = 'push';
          state.bankroll += wager;
          pushMessage(`Hand ${index + 1}: Push. Bet returned ($${formatCurrency(wager)}).`);
        }
      });

      pushMessage('Click Deal to play again.');
      setFinished();
    }

    function advanceHand() {
      state.activeHand += 1;
      const hasNext = state.activeHand < state.playerHands.length;
      if (hasNext) {
        resetMessages(`Playing Hand ${state.activeHand + 1}.`);
        updateUI();
      } else {
        resetMessages('Dealer reveals...');
        updateUI();
        startDealerTurn();
      }
    }

    function startRound() {
      if (!state.finished) {
        return;
      }
      state.baseBet = currentBetTotal();
      if (state.baseBet <= 0) {
        resetMessages('Place a bet to play.');
        updateUI();
        return;
      }
      if (state.baseBet > state.bankroll) {
        resetMessages('Insufficient bankroll for that bet.');
        updateUI();
        return;
      }

      state.deck = createDeck();
      state.dealer = [drawCard(), drawCard()];
      state.playerHands = [
        {
          cards: [drawCard(), drawCard()],
          status: 'playing',
          hasActed: false,
          result: null,
          wager: state.baseBet,
        },
      ];
      state.bankroll -= state.baseBet;
      state.activeHand = 0;
      state.revealDealer = false;
      state.finished = false;
      resetMessages('Choose an action.');

      const playerHand = state.playerHands[0];
      const playerBJ = isBlackjack(playerHand.cards);
      const dealerBJ = isBlackjack(state.dealer);
      if (playerBJ || dealerBJ) {
        state.revealDealer = true;
        state.finished = true;
        if (playerBJ && dealerBJ) {
          playerHand.result = 'push';
          playerHand.status = 'stood';
          resetMessages(`Both have blackjack. Push ($${formatCurrency(playerHand.wager)}).`);
          state.bankroll += playerHand.wager;
        } else if (playerBJ) {
          playerHand.result = 'blackjack';
          playerHand.status = 'stood';
          const profit = playerHand.wager * 1.5;
          state.bankroll += playerHand.wager * 2.5;
          resetMessages(`Blackjack! You win $${formatCurrency(profit)}.`);
        } else {
          playerHand.result = 'lose';
          playerHand.status = 'stood';
          resetMessages('Dealer blackjack. You lose.');
        }
        updateUI();
        return;
      }

      updateUI();
    }

    function hit() {
      const hand = state.playerHands[state.activeHand];
      if (!hand || state.finished) {
        return;
      }
      hand.cards.push(drawCard());
      hand.hasActed = true;
      const total = handValue(hand.cards);
      if (total > 21) {
        hand.status = 'bust';
        resetMessages(`Hand ${state.activeHand + 1} busts!`);
        advanceHand();
      } else {
        resetMessages(`Hand ${state.activeHand + 1}: Total ${total}.`);
        updateUI();
      }
    }

    function stand() {
      const hand = state.playerHands[state.activeHand];
      if (!hand || state.finished) {
        return;
      }
      hand.status = 'stood';
      hand.hasActed = true;
      resetMessages(`Hand ${state.activeHand + 1} stands at ${handValue(hand.cards)}.`);
      advanceHand();
    }

    function doubleDown() {
      const hand = state.playerHands[state.activeHand];
      if (!hand || state.finished || hand.cards.length !== 2 || hand.hasActed) {
        return;
      }
      const additional = hand.wager || state.baseBet;
      if (state.bankroll < additional) {
        resetMessages('Not enough bankroll to double down.');
        updateUI();
        return;
      }
      state.bankroll -= additional;
      hand.wager = (hand.wager || state.baseBet) + additional;
      hand.cards.push(drawCard());
      hand.hasActed = true;
      const total = handValue(hand.cards);
      if (total > 21) {
        hand.status = 'bust';
        resetMessages(`Double bust! Hand ${state.activeHand + 1} loses.`);
      } else {
        hand.status = 'stood';
        resetMessages(`Double down to ${total}.`);
      }
      advanceHand();
    }

    function split() {
      const hand = state.playerHands[state.activeHand];
      if (!hand || state.finished || !canSplit(hand)) {
        return;
      }
      const wager = hand.wager || state.baseBet;
      if (state.bankroll < wager) {
        resetMessages('Not enough bankroll to split.');
        updateUI();
        return;
      }
      const secondCard = hand.cards.pop();
      const newHand = {
        cards: [secondCard],
        status: 'playing',
        hasActed: false,
        result: null,
        wager,
      };
      state.bankroll -= wager;
      hand.hasActed = false;
      hand.status = 'playing';
      hand.wager = wager;
      hand.cards = [hand.cards[0]];
      hand.cards.push(drawCard());
      newHand.cards.push(drawCard());
      state.playerHands.splice(state.activeHand + 1, 0, newHand);
      resetMessages('Hand split! Continue playing current hand.');
      updateUI();
    }

    newGameButton.addEventListener('click', startRound);
    hitButton.addEventListener('click', hit);
    standButton.addEventListener('click', stand);
    doubleButton.addEventListener('click', doubleDown);
    splitButton.addEventListener('click', split);

    chipButtons.forEach((button) => {
      button.addEventListener('click', () => {
        selectChip(button.dataset.amount);
      });
    });

    if (clearBetButton) {
      clearBetButton.addEventListener('click', clearBet);
    }

    if (betArea) {
      betArea.addEventListener('click', handleBetAreaClick);
    }

    if (toggleButton) {
      toggleButton.addEventListener('click', () => {
        state.collapsed = !state.collapsed;
        updateUI();
      });
    }

    updateUI();
  }());

  document.querySelectorAll('[data-incremental-container]').forEach((container) => {
    const list = container.querySelector('[data-incremental-list]');
    if (!list) {
      return;
    }
    const batchSize = parseInt(container.dataset.batchSize || '5', 10);
    const initialVisible = parseInt(container.dataset.initialVisible || String(batchSize), 10);
    const items = Array.from(list.querySelectorAll('[data-incremental-item]'));
    const loadMoreButton = container.querySelector('[data-load-more]');

    if (!items.length) {
      if (loadMoreButton) {
        loadMoreButton.classList.add('hidden');
      }
      return;
    }

    let visibleCount = Math.min(initialVisible, items.length);

    const updateVisibility = () => {
      items.forEach((item, index) => {
        if (index < visibleCount) {
          item.classList.remove('hidden');
        } else {
          item.classList.add('hidden');
        }
      });
      if (loadMoreButton) {
        if (visibleCount >= items.length) {
          loadMoreButton.classList.add('hidden');
        } else {
          loadMoreButton.classList.remove('hidden');
        }
      }
    };

    if (loadMoreButton) {
      loadMoreButton.addEventListener('click', () => {
        visibleCount = Math.min(visibleCount + batchSize, items.length);
        updateVisibility();
      });
    }

    updateVisibility();
  });
</script>
</body>
</html>
