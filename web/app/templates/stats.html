{% extends "base.html" %}
{% block content %}
<h1 class="text-2xl font-bold mb-4">Player Performance</h1>
<p class="text-sm text-gray-600">Overall record and profitability for each player based on finished wagers.</p>
<p class="text-xs text-gray-500 mb-6">Free play wagers still count toward wins/losses but do not contribute to staked totals or losses.</p>

<div class="overflow-x-auto bg-white rounded-xl shadow mb-8">
  <table class="min-w-full divide-y divide-gray-200 text-sm">
    <thead class="bg-gray-50">
      <tr>
        <th class="px-4 py-3 text-left font-semibold text-gray-700">Player</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Wagers</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Wins</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Losses</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Open</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Archived</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Win %</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Staked</th>
        <th class="px-4 py-3 text-right font-semibold text-gray-700">Profit</th>
      </tr>
    </thead>
    <tbody class="divide-y divide-gray-100">
      {% for stat in player_stats %}
      <tr>
        <td class="px-4 py-3 font-medium text-gray-900 flex items-center gap-3">
          <img src="{{ stat.user.profile_pic_url }}" alt="{{ stat.user.display_name }}" class="w-8 h-8 rounded-full">
          <span>{{ stat.user.display_name }}</span>
        </td>
        <td class="px-4 py-3 text-right text-gray-700">{{ stat.total }}</td>
        <td class="px-4 py-3 text-right text-green-600 font-semibold">{{ stat.wins }}</td>
        <td class="px-4 py-3 text-right text-red-500 font-semibold">{{ stat.losses }}</td>
        <td class="px-4 py-3 text-right text-gray-600">{{ stat.open }}</td>
        <td class="px-4 py-3 text-right text-gray-600">{{ stat.archived }}</td>
        <td class="px-4 py-3 text-right text-gray-700">{{ '{:.1f}%'.format(stat.win_rate) }}</td>
        <td class="px-4 py-3 text-right text-gray-700">${{ '{:,.2f}'.format(stat.staked) }}</td>
        <td class="px-4 py-3 text-right font-semibold {{ 'text-green-600' if stat.profit >= 0 else 'text-red-500' }}">${{ '{:,.2f}'.format(stat.profit) }}</td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>

<div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-between mb-3">
  <h2 class="text-xl font-semibold">Performance Over The Last {{ range_label }}</h2>
  <div class="flex flex-wrap items-center gap-2 text-sm font-medium">
    {% for option in range_options %}
    {% set is_active = option.key == selected_range %}
    <a href="{{ url_for('view_stats') }}?range={{ option.key }}"
       class="range-tab px-3 py-1.5 rounded-full {{ 'bg-blue-600 text-white' if is_active else 'bg-gray-200 text-gray-700' }}"
       aria-pressed="{{ 'true' if is_active else 'false' }}">
      {{ option.label }}
    </a>
    {% endfor %}
  </div>
</div>
{% if has_chart %}
<div class="flex items-center gap-2 mb-3">
  <button type="button" data-chart="profit" aria-pressed="true"
          class="chart-tab px-3 py-1.5 rounded-full text-sm font-medium bg-blue-600 text-white">
    Profit / Loss
  </button>
  <button type="button" data-chart="bets" aria-pressed="false"
          class="chart-tab px-3 py-1.5 rounded-full text-sm font-medium bg-gray-200 text-gray-700">
    Bets Placed
  </button>
</div>
<div class="bg-white rounded-xl shadow p-4 relative">
  <canvas id="profit-chart" height="120"></canvas>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script id="chart-data" type="application/json">{{ chart_payload | safe }}</script>
<script>
  const chartDataElement = document.getElementById('chart-data');
  const chartConfig = JSON.parse(chartDataElement.textContent || '{}');
  const datasetsByKey = {
    profit: chartConfig.profit || [],
    bets: chartConfig.bets || [],
  };
  const DENSE_WAGER_THRESHOLD = 7;
  const COLLAPSED_WAGER_COUNT = 4;
  const dateRange = chartConfig.range || {};
  const palette = ['#2563eb', '#dc2626', '#16a34a', '#9333ea', '#f97316', '#0891b2'];
  const escapeHtml = (value = '') => String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
  const parseDateValue = (value) => {
    if (typeof value === 'number') {
      return value;
    }
    if (typeof value === 'string') {
      const dateOnlyMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
      if (dateOnlyMatch) {
        const [_, year, month, day] = dateOnlyMatch;
        return new Date(Number(year), Number(month) - 1, Number(day)).getTime();
      }
      const parsed = Date.parse(value);
      if (!Number.isNaN(parsed)) {
        return parsed;
      }
    }
    return null;
  };
  const formatCurrency = (value) => {
    if (typeof value !== 'number' || Number.isNaN(value)) {
      return '$0.00';
    }
    const sign = value < 0 ? '-' : '';
    return `${sign}$${Math.abs(value).toFixed(2)}`;
  };
  const formatStatusLabel = (status) => {
    const normalized = typeof status === 'string' ? status.toLowerCase() : '';
    const mapping = {
      won: {text: 'Won', className: 'text-green-600 font-semibold'},
      lost: {text: 'Lost', className: 'text-red-500 font-semibold'},
      open: {text: 'Open', className: 'text-gray-600 font-medium'},
      removed: {text: 'Removed', className: 'text-gray-500 font-medium'},
    };
    const meta = mapping[normalized] || {text: 'Pending', className: 'text-gray-500 text-xs font-medium'};
    return `<span class="${meta.className}">${escapeHtml(meta.text)}</span>`;
  };
  const buildDetailMarkup = (details) => {
    if (!details.length) {
      return '<div class="text-xs text-gray-500">No bets recorded for this day.</div>';
    }
    return details.map((detail) => {
      const statusLabel = formatStatusLabel(detail.status);
      const profit = typeof detail.profit === 'number' && !Number.isNaN(detail.profit) ? detail.profit : null;
      const showProfit = profit !== null && ['won', 'lost'].includes((detail.status || '').toLowerCase());
      const profitLabel = showProfit
        ? (() => {
            const prefix = profit >= 0 ? '+' : '-';
            const color = profit >= 0 ? 'text-green-600' : 'text-red-500';
            return `<span class="${color} font-semibold">${prefix}${formatCurrency(Math.abs(profit))}</span>`;
          })()
        : statusLabel;
      const wagerLabel = escapeHtml(detail.description || `Wager #${detail.id}`);
      const amount = typeof detail.amount === 'number' && !Number.isNaN(detail.amount)
        ? `<div class="text-xs text-gray-500 mt-0.5">Stake: ${formatCurrency(detail.amount)}</div>`
        : '';
      const badges = [];
      if (detail.is_live_bet) {
        badges.push('<span class="text-lg" title="Live bet">ðŸš¨</span>');
      }
      if (detail.is_free_play) {
        badges.push('<span class="inline-flex items-center px-2 py-0.5 rounded-full bg-purple-100 text-purple-700 text-[10px] font-semibold uppercase tracking-wide">Free Play</span>');
      }
      const badgeMarkup = badges.length
        ? `<div class="flex items-center gap-2 text-xs text-gray-600">${badges.join('')}</div>`
        : '';
      return `
        <div class="flex flex-col gap-1 border border-gray-100 rounded-lg px-3 py-2 bg-gray-50">
          <div class="flex items-start justify-between gap-3">
            <div class="text-sm text-gray-800 font-medium leading-snug">${wagerLabel}</div>
            <div class="text-sm whitespace-nowrap">${profitLabel}</div>
          </div>
          ${badgeMarkup}
          ${amount}
        </div>
      `;
    }).join('');
  };
  const getOrCreateTooltip = (chartInstance) => {
    let tooltipEl = chartInstance.canvas.parentNode.querySelector('.chartjs-tooltip');
    if (!tooltipEl) {
      tooltipEl = document.createElement('div');
      tooltipEl.className = 'chartjs-tooltip absolute z-10';
      tooltipEl.style.opacity = 0;
      tooltipEl.style.transition = 'opacity 150ms ease';
      tooltipEl.innerHTML = '<div class="rounded-lg bg-white shadow-xl border border-gray-200 p-3 text-sm max-w-xs"></div>';
      chartInstance.canvas.parentNode.appendChild(tooltipEl);
    }
    if (!tooltipEl.dataset.boundClick) {
      tooltipEl.addEventListener('click', () => {
        const key = tooltipEl.dataset.pointKey;
        if (!key || !tooltipEl.dataset.canExpand) {
          return;
        }
        expandedTooltipKey = expandedTooltipKey === key ? null : key;
        if (lastTooltipContext) {
          externalTooltipHandler(lastTooltipContext);
        }
      });
      tooltipEl.dataset.boundClick = 'true';
    }
    return tooltipEl;
  };
  let expandedTooltipKey = null;
  let lastTooltipContext = null;
  const externalTooltipHandler = (context) => {
    const {chart, tooltip} = context;
    const tooltipEl = getOrCreateTooltip(chart);
    if (tooltip.opacity === 0 || !tooltip.dataPoints || !tooltip.dataPoints.length) {
      tooltipEl.style.opacity = 0;
      tooltipEl.style.pointerEvents = 'none';
      tooltipEl.dataset.pointKey = '';
      tooltipEl.dataset.canExpand = '';
      return;
    }
    const dataPoint = tooltip.dataPoints[0];
    const label = dataPoint.dataset?.label || '';
    const metric = dataPoint.dataset?.metric || '';
    const value = typeof dataPoint.parsed?.y === 'number' ? dataPoint.parsed.y : 0;
    const details = Array.isArray(dataPoint.raw?.bets) ? dataPoint.raw.bets : [];
    const dateLabel = new Intl.DateTimeFormat(undefined, {weekday: 'short', month: 'short', day: 'numeric', year: 'numeric'})
      .format(new Date(dataPoint.parsed.x));
    const summaryVerb = metric === 'bets' ? 'placed' : 'resolved';
    const summaryCount = details.length
      ? `${details.length} bet${details.length === 1 ? '' : 's'} ${summaryVerb}`
      : `No bets ${summaryVerb}`;
    const summaryValue = metric === 'bets'
      ? `${value} total`
      : `Cumulative: ${formatCurrency(value)}`;
    const currentKey = `${dataPoint.datasetIndex}-${dataPoint.dataIndex}-${dataPoint.parsed.x}`;
    const isDense = details.length > DENSE_WAGER_THRESHOLD;
    const isExpanded = expandedTooltipKey === currentKey;
    const visibleDetails = isDense && !isExpanded ? details.slice(0, COLLAPSED_WAGER_COUNT) : details;
    const overflowClass = isDense && isExpanded ? 'max-h-64 overflow-y-auto pr-1' : '';
    const denseHint = isDense
      ? `<div class="text-[11px] text-blue-600 font-semibold mt-2">${isExpanded ? 'Click to collapse list' : 'Multiple wagers â€” click to expand'}</div>`
      : '';
    const moreNote = isDense && !isExpanded && details.length > COLLAPSED_WAGER_COUNT
      ? `<div class="text-[11px] text-gray-500">Showing ${COLLAPSED_WAGER_COUNT} of ${details.length} wagers</div>`
      : '';
    tooltipEl.querySelector('div').innerHTML = `
      <div class="text-xs font-semibold text-gray-500 mb-1">${escapeHtml(label)}</div>
      <div class="text-sm font-bold text-gray-900">${escapeHtml(dateLabel)}</div>
      <div class="text-xs text-gray-600 mb-2">${escapeHtml(summaryCount)} Â· ${escapeHtml(summaryValue)}</div>
      <div class="flex flex-col gap-2 ${overflowClass}">${buildDetailMarkup(visibleDetails)}</div>
      ${moreNote}
      ${denseHint}
    `;

    const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;
    tooltipEl.style.opacity = 1;
    tooltipEl.style.left = `${positionX + tooltip.caretX + 12}px`;
    tooltipEl.style.top = `${positionY + tooltip.caretY - tooltipEl.offsetHeight / 2}px`;
    tooltipEl.style.pointerEvents = isDense ? 'auto' : 'none';
    tooltipEl.dataset.pointKey = currentKey;
    tooltipEl.dataset.canExpand = isDense ? 'true' : '';
    lastTooltipContext = context;
  };

  const prepareDatasets = (datasets) => datasets.map((dataset, index) => {
    const color = dataset.borderColor || palette[index % palette.length];
    const points = (dataset.data || []).map((point) => ({
      x: parseDateValue(point.x),
      y: point.y,
      bets: point.bets || [],
      rawDate: point.x,
    }));
    return {
      ...dataset,
      data: points,
      borderWidth: 2,
      fill: false,
      pointRadius: 4,
      pointHoverRadius: 6,
      borderColor: color,
      backgroundColor: dataset.backgroundColor || color,
    };
  });

  const defaultKey = datasetsByKey.profit.length ? 'profit' : 'bets';
  const context = document.getElementById('profit-chart').getContext('2d');
  const chart = new Chart(context, {
    type: 'line',
    data: {
      datasets: prepareDatasets(datasetsByKey[defaultKey] || []),
    },
    options: {
      responsive: true,
      interaction: {
        mode: 'nearest',
        intersect: false,
      },
      scales: {
        x: {
          type: 'time',
          time: {
            tooltipFormat: 'PP',
            unit: 'day',
            displayFormats: {
              day: 'MMM d',
            },
          },
          title: {
            display: true,
            text: 'Date',
          },
        },
        y: {
          beginAtZero: defaultKey === 'bets',
          title: {
            display: true,
            text: defaultKey === 'bets' ? 'Bets Placed' : 'Total Profit / Loss ($)',
          },
        },
      },
      plugins: {
        tooltip: {
          enabled: false,
          external: externalTooltipHandler,
        },
        legend: {
          position: 'bottom',
        },
      },
    },
  });

  const tabs = document.querySelectorAll('.chart-tab');
  const hideCustomTooltip = () => {
    const tooltipEl = context.canvas.parentNode.querySelector('.chartjs-tooltip');
    if (tooltipEl) {
      tooltipEl.style.opacity = 0;
    }
  };
  const describePoint = (point, dataset) => {
    const dateValue = typeof point.rawDate !== 'undefined' ? point.rawDate : point.x;
    const parsedDate = parseDateValue(dateValue);
    const dateLabel = parsedDate
      ? new Intl.DateTimeFormat(undefined, {weekday: 'long', month: 'long', day: 'numeric', year: 'numeric'}).format(new Date(parsedDate))
      : 'Unknown date';
    const metric = dataset.metric || defaultKey;
    const details = Array.isArray(point.bets) ? point.bets : [];
    const summaryCount = details.length
      ? `${details.length} bet${details.length === 1 ? '' : 's'} ${metric === 'bets' ? 'placed' : 'resolved'}`
      : `No bets ${metric === 'bets' ? 'placed' : 'resolved'}`;
    const summaryValue = metric === 'bets'
      ? `${point.y} total`
      : `Cumulative: ${formatCurrency(point.y)}`;
    return {
      label: dataset.label || 'Player',
      metric,
      dateLabel,
      summaryCount,
      summaryValue,
      details,
    };
  };
  context.canvas.addEventListener('click', (event) => {
    const points = chart.getElementsAtEventForMode(event, 'nearest', {intersect: true}, true);
    if (!points.length) {
      return;
    }
    const first = points[0];
    const dataset = chart.data.datasets[first.datasetIndex];
    const point = dataset.data[first.index];
    const details = Array.isArray(point.bets) ? point.bets : [];
    if (!details.length) {
      return;
    }
    renderDetailPanel(describePoint(point, dataset));
  });

  const applyAxisRange = () => {
    const min = parseDateValue(dateRange.start);
    const max = parseDateValue(dateRange.end);
    if (typeof min === 'number' && !Number.isNaN(min)) {
      chart.options.scales.x.min = min;
    } else {
      delete chart.options.scales.x.min;
    }
    if (typeof max === 'number' && !Number.isNaN(max)) {
      chart.options.scales.x.max = max;
    } else {
      delete chart.options.scales.x.max;
    }
  };

  const activateTab = (key) => {
    tabs.forEach((tab) => {
      const isActive = tab.dataset.chart === key;
      tab.classList.toggle('bg-blue-600', isActive);
      tab.classList.toggle('text-white', isActive);
      tab.classList.toggle('bg-gray-200', !isActive);
      tab.classList.toggle('text-gray-700', !isActive);
      tab.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });

    chart.data.datasets = prepareDatasets(datasetsByKey[key] || []);
    chart.options.scales.y.beginAtZero = key === 'bets';
    if (key === 'bets') {
      chart.options.scales.y.min = 0;
      chart.options.scales.y.title.text = 'Bets Placed';
    } else {
      delete chart.options.scales.y.min;
      chart.options.scales.y.title.text = 'Total Profit / Loss ($)';
    }
    chart.update();
    hideCustomTooltip();
  };

  tabs.forEach((tab) => {
    tab.addEventListener('click', () => activateTab(tab.dataset.chart));
  });

  applyAxisRange();
  activateTab(defaultKey);
</script>
{% else %}
<p class="text-sm text-gray-500">No completed wagers yetâ€”profit chart will appear once bets are graded.</p>
{% endif %}
{% endblock %}
